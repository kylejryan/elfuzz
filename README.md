# ELFuzz

[![Artifacts DOI](https://img.shields.io/badge/Artifacts_DOI-10.5281%2Fzenodo.15833146-green)](https://doi.org/10.5281/zenodo.15833146)

This repository contains the source code of the replication package of the paper "ELFuzz: Efficient Input Generation via LLM-driven Synthesis Over Fuzzer Space."

## Quick start (Docker)

1. Pull the published image: `docker pull ghcr.io/osuseclab/elfuzz:25.08.0`.
2. Allow core dumps (needed by AFL++ later): `echo core > /proc/sys/kernel/core_pattern`.
3. Launch the container with adequate CPU/disk (example below is what we used):  
   `docker run --storage-opt size=100G --cpus 30 -it --add-host=host.docker.internal:host-gateway -v /tmp/host:/tmp/host -v /var/run/docker.sock:/var/run/docker.sock --name elfuzz ghcr.io/osuseclab/elfuzz:25.08.0`
4. Inside the container, run a smoke test with small resources:  
   `elfuzz synth -T fuzzer.elfuzz jsoncpp --use-small-model --evolution-iterations 1`

## How to use the ELFuzz CLI

- The CLI lives in `cli/` and is exposed as `elfuzz` inside the Docker image (or `python -m cli.main` on the host). Run `elfuzz --help` for top-level commands.
- Common flows (all paths relative to the container’s `/home/appuser/elmfuzz/`):
  - Synthesize fuzzers or artifacts: `elfuzz synth -T fuzzer.elfuzz jsoncpp --use-small-model` or `elfuzz synth -T grammar.glade jsoncpp`.
  - Produce seed test cases: `elfuzz produce -T elfuzz jsoncpp --time 60` (writes under `extradata/seeds/raw/jsoncpp/`).
  - Minimize seeds: `elfuzz minimize -T elfuzz jsoncpp` (tarballs end up in `extradata/seeds/cmined_with_control_bytes/`).
  - Run evaluations (RQ1 coverage and AFL campaigns): `elfuzz run rq1.seed_cov -T elfuzz jsoncpp` or `elfuzz run rq1.afl --fuzzers "elfuzz,grmr,isla,islearn,glade" --repeat 10 "jsoncpp,libxml2,re2,cpython3,sqlite3,cvc5,librsvg"`.
- Development on the host: you can call `python -m cli.main` from the repo root, but most experiments assume the container environment, symlink layout, and data pulled via `elfuzz download`.

## Target scope and cautions

- Supported/validated benchmarks are: `jsoncpp`, `libxml2`, `re2`, `cpython3`, `sqlite3`, `cvc5`, and `librsvg`. The CLI choices enforce this list.
- Do not point the tooling at arbitrary projects without adding a proper harness and adapters; paths and expectations (e.g., AFL++ integration, grammar mining layouts) are wired to the benchmarks above.
- Generated artifacts are large. Keep `extradata/`, `preset/`, and `tmp/` out of commits and be aware runs can consume tens of GB.

## Experiment data

The experiment data are published on [Zenodo](https://doi.org/10.5281/zenodo.15833146).

## Replication package

The code and environment to replicate the experiments are published as a Docker image. Run the following command to pull it:

```bash
docker pull ghcr.io/osuseclab/elfuzz:25.08.0
```

Before launching docker, set up core_patterns for the host machine, which is required by AFL++ later:

```bash
echo core > /proc/sys/kernel/core_pattern
```

Instead, if you download the Docker image as a tarball from Zenodo, you can import it using the following commands:

```bash
zstd -d "elfuzz_docker_<timetag>.tar.zst"
docker load --input "elfuzz_docker_<timetag>.tar"
```

After pulling/importing the image, run the following command to start the container:

```bash
mkdir -p /tmp/host
docker run --storage-opt size=100G --cpus 30 -it --add-host=host.docker.internal:host-gateway -v /tmp/host:/tmp/host -v /var/run/docker.sock:/var/run/docker.sock --name elfuzz ghcr.io/osuseclab/elfuzz:25.08.0
```

Explanation of the command is as follows:

- `--storage-opt size=100G`: Allocates 100 GB of disk space to the container. We need this as some files generated/downloaded during the experiments are large, such as the models pulls from Hugging Face and the seed test cases generated by ELFuzz fuzzers.
- `--cpus 32`: Allocates 32 CPU cores to the container. This is to speed up operations such as minimizing seed test cases via parallelization.
- `-it`: Runs the container in interactive mode with a terminal.
- `--add-host=host.docker.internal:host-gateway`: Adds a host entry to the container so that it can access the host machine. This is needed for query the LLM served in a [sibling container](https://stackoverflow.com/questions/39151188/is-there-a-way-to-start-a-sibling-docker-container-mounting-volumes-from-the-hos).
- `-v /tmp/host:/tmp/host`: Mounts the `/tmp/host` directory on the host machine into the container as a shared temporary directory with sibling containers.
- `-v "/var/run/docker.sock:/var/run/docker.sock"`: Mounts the Docker socket into the container, allowing it to run sibling containers.
- `--name elfuzz`: Names the container `elfuzz`.
- `ghcr.io/osuseclab/elfuzz:25.08.0`: Specifies the Docker image to use.

This will enter a shell into the container. Then, following the instructions in `/elfuzz/README.md` (which is a symlink to [docker_readme.md](docker_readme.md) in this repository) to replicate the experiments.

The Docker image has only been tested on X86-64 machines.

## Development and linting

- Python environment: use `uv` to manage the venv and tools. Create once with `UV_CACHE_DIR=.uv-cache uv venv .venv && source .venv/bin/activate`.
- Install dev tooling from `pyproject.toml` extras: `uv pip install -e '.[dev]'`.
- Python lint/format: `uv run ruff check .` and `uv run ruff format .` (ruff uses settings in `pyproject.toml`). `uv run black .` is available if you prefer Black’s formatter.
- Rust (only under `evaluation/glade/sqlite3_parser/`): run `cargo fmt` and `cargo test`.
- Shell: keep scripts POSIX/bash-friendly; use `shellcheck` where available. See `.editorconfig` for consistent indentation and newlines.

## How to build the Docker image

Before building the Docker image, you should `cd` to the root of the ELFuzz source code and put `elfuzz_baselines.tar.zst` (downloaded from Zenodo) into `tmp/`.

The Docker image is built by the following command:

```bash
docker build -t ghcr.io/osuseclab/elfuzz:25.08.0 -f .devcontainer/Dockerfile --target publish .
```

## Source code layout

First, I'm sorry that the codebase is messy. It is hard to keep it clean while rushing towards the paper deadline.

TODO

## Miscellaneous

- The Docker version at the time that the image was built is 28.2.2.
- There is a PDF (`misc/sibling_container.pdf`) in the data tarball (`elfuzz_data_<timestamp>.tar.zst`) downloaded from the Zenodo repository. It is a persistent version of the Stack Overflow post referenced above, in case that the link to the post is broken in the future.

## Maintenance statements

- \[2025-06-19\] I tried my best to preserve the environment in the Docker image, keeping the replication package usable for as long as possible. However, there may be some aspects that I have not considered. If you encounter any issues that prevent you from using the package, please open an issue or launch a pull request.

## Cite this work

```bibtex
@inproceedings{chen2025elfuzz,
  title = {{ELFuzz}: {Efficient} Input Generation via LLM-driven Synthesis Over
Fuzzer Space},
  booktitle = {Proceedings of the 34th {USENIX Security Symposium} ({USENIX} {Security} 2025)},
  author = {Chen, Chuyang and Dolan-Gavitt, Brendan and Lin, Zhiqiang},
  year = {2025},
  pages = {6279--6298},
  month = {8},
  publisher = {USENIX Association},
  address = {Seattle, WA, USA},
  copyright = {All rights reserved},
}
```
